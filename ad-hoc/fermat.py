n = 2318754427090927622417300593014303163027836982793164162950666250489681094136583599882469330682357229700000166714186122335692872792460409101465630110622887313064657894574037981904943176292533073634387002369380564791579428603519429963490374738649708747360755590037132507998435966068658633431918622092817702780128462915129741083129108481836485937804951555271147615962278158353917059561029043381242474374972583682945918237047674797098894662717409552897418650427548642489575961500481014997803061734956091625431696419759919121068387038071453059311371255995535187052409462363525765654622645413142987775053860188260137197659
e = 65537
c = 1852258477078452495280071169336816541669321769289372837198526954361460776833319048556839287633046754304414868057993901219892835088957705515939202089076460374548771033553266251154753679870528816210706553445963568771841753267644973871132621342897934474998162148362874305941012572949171990616677298854465965898581914403406403426504250013897086136105989549801404176555930509653029014518314103310549883855327513190607775750086851774949594618287441246861446444592130784569563671269161854267497652454746479173284327272563799067627736512266913669944284375302659511122504002144054772208775215907860036195680830269422876824977

from Crypto.Util.number import long_to_bytes, inverse
import gmpy2
from sympy import isprime

def fermat_factorization(n):
    if n <= 0:
        return "n phải là số nguyên dương."
    if n % 2 == 0:
        return (n // 2, 2)  # Trả về một cặp thừa số nếu n là số chẵn

    a = gmpy2.isqrt(n)
    if a * a < n:
        a += 1
    b2 = a * a - n
    b = gmpy2.isqrt(b2)

    while b * b != b2:
        a += 1
        b2 = a * a - n
        b = gmpy2.isqrt(b2)

    return (a - b, a + b)

factors = fermat_factorization(n)

a = factors[0]
b = factors[1]
y = (a + b) // 2
x = b - y

x = x * 2
y = y * 2

p = (x + y) // 2
q = y - p

print("p, q: ", p, q)
print(p * q == n)

print(isprime(q), isprime(p))

u = 6939268454184877330211144138413966814481101061382015473621711919814088916348213343387168181954880781520959109737312885406280110070698427014630125251118873
v = 6939268454184877330211144138413966814481101061382015473621711919814088916348213343387168181954880781520959109737312885406280110070698427014630125251119529
s = 6939268454184877330211144138413966814481101061382015473621711919814088916348213343387168181954880781520959109737312885406280110070698427014630125251118111
t = 6939268454184877330211144138413966814481101061382015473621711919814088916348213343387168181954880781520959109737312885406280110070698427014630125251119557

print(u * v * s * t == n)

phi = (u - 1) * (v - 1) * (s - 1) * (t - 1)

d = inverse(e, phi)
print("d:", d)

m = pow(c, d, n)

print(long_to_bytes(m))

#ASCWG{you_need_fermat_factorization_to_solve_RSA_Small_diffrince_Prime_Attack_12312}